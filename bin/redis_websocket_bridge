#!/usr/bin/env ruby

# Subscribe to all redis channel messages and deliver them
# to any websockets that have registered ro receive them.

# The typical pattern is to use GlobalID IDs as channel name.

require 'optparse'
require_relative '../lib/redis_websocket_bridge/server'

pid_file = File.join(Dir.tmpdir, 'rwb.pid')
if File.exists? pid_file
  STDERR.puts "pid file exists at #{pid_file}"
  exit -1
end
open(pid_file, 'w') { |out| out.puts $$ }
at_exit do
  puts "deleting pid file #{pid_file}"
  File.delete pid_file
end

STDOUT.sync = true

options = {}
OptionParser.new do |opts|
  opts.on('-v', '--verbose') do |verbose|
    options[:log_level] = 'DEBUG'
  end

  opts.on('-p', '--port port', Float) do |port|
    options[:port] = port.to_i
  end

  opts.on('-t', '--logtick log tick', Integer) do |log_tick|
    options[:log_tick] = log_tick.to_i
  end

  opts.on('-p', '--prefix log prefix') do |prefix|
    options[:log_prefix] = prefix
  end
end.parse!

server = RedisWebsocketBridge::Server.new options
server.run!
